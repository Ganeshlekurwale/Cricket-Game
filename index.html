<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>3D Cricket Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: linear-gradient(to bottom, #87ceeb, #98fb98);
        font-family: Arial, sans-serif;
        touch-action: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 100;
        color: white;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px 15px;
        border-radius: 8px;
        font-size: 14px;
        max-width: 200px;
      }

      #ui h2 {
        margin: 0 0 8px 0;
        font-size: 18px;
      }

      #ui p {
        margin: 4px 0;
        font-size: 12px;
      }

      #controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
        max-width: 90vw;
      }

      .btn {
        padding: 12px 20px;
        font-size: 16px;
        font-weight: bold;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        background: linear-gradient(45deg, #4caf50, #45a049);
        color: white;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        min-width: 80px;
        touch-action: manipulation;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
      }

      .btn:active {
        transform: translateY(0);
      }

      #bat-btn {
        background: linear-gradient(45deg, #8b4513, #a0522d);
      }
      #ball-btn {
        background: linear-gradient(45deg, #ff6b6b, #ff5252);
      }
      #stump-btn {
        background: linear-gradient(45deg, #ffd700, #ffa000);
      }

      #result {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 200;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 20px;
        border-radius: 12px;
        font-size: 18px;
        text-align: center;
        display: none;
        max-width: 300px;
        width: 90vw;
        box-sizing: border-box;
      }

      #result h3 {
        margin: 0 0 15px 0;
        font-size: 24px;
      }

      #result p {
        margin: 8px 0;
        font-size: 16px;
      }

      #result button {
        margin-top: 15px;
        padding: 12px 24px;
        font-size: 16px;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        touch-action: manipulation;
      }

      /* Mobile Touch Controls */
      #touch-controls {
        position: absolute;
        bottom: 150px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        display: none;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 8px;
        color: white;
        font-size: 12px;
        text-align: center;
      }

      #touch-joystick {
        position: absolute;
        bottom: 100px;
        right: 20px;
        width: 80px;
        height: 80px;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        display: none;
        z-index: 100;
      }

      #touch-joystick-knob {
        position: absolute;
        width: 30px;
        height: 30px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        transition: all 0.1s ease;
      }

      /* Mobile Media Query */
      @media (max-width: 768px) {
        #ui {
          top: 5px;
          left: 5px;
          padding: 8px 12px;
          font-size: 12px;
          max-width: 150px;
        }

        #ui h2 {
          font-size: 16px;
        }

        #ui p {
          font-size: 11px;
        }

        #controls {
          bottom: 10px;
          gap: 8px;
        }

        .btn {
          padding: 10px 16px;
          font-size: 14px;
          min-width: 70px;
        }

        #touch-controls {
          display: block;
        }

        #touch-joystick {
          display: block;
        }

        #result {
          padding: 15px;
          font-size: 16px;
          max-width: 280px;
        }

        #result h3 {
          font-size: 20px;
        }

        #result p {
          font-size: 14px;
        }
      }

      @media (max-width: 480px) {
        #ui {
          font-size: 11px;
          max-width: 130px;
        }

        #ui h2 {
          font-size: 14px;
        }

        .btn {
          padding: 8px 12px;
          font-size: 12px;
          min-width: 60px;
        }

        #result {
          padding: 12px;
          font-size: 14px;
        }

        #result h3 {
          font-size: 18px;
        }

        #result p {
          font-size: 13px;
        }
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <div id="ui">
        <h2>3D Cricket Game</h2>
        <p>Score: <span id="score">0</span></p>
        <p>Matches: <span id="matches">0</span></p>
        <p>Choose your move!</p>
      </div>

      <div id="touch-controls">
        <p>üëÜ Touch and drag to look around</p>
        <p>üéÆ Use virtual joystick to move</p>
      </div>

      <div id="touch-joystick">
        <div id="touch-joystick-knob"></div>
      </div>

      <div id="controls">
        <button class="btn" id="bat-btn" onclick="playGame('Bat')">
          üèè Bat
        </button>
        <button class="btn" id="ball-btn" onclick="playGame('Ball')">
          ü•é Ball
        </button>
        <button class="btn" id="stump-btn" onclick="playGame('Stump')">
          üèè Stump
        </button>
      </div>

      <div id="result">
        <div id="result-text"></div>
        <button onclick="closeResult()">Play Again</button>
      </div>
    </div>

    <script>
      // Game variables
      let scene, camera, renderer, bat, ball, stumps, field;
      let score = 0;
      let matches = 0;
      let isAnimating = false;

      // Mobile detection
      let isMobile =
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        );

      // Touch controls
      let touchStartX = 0,
        touchStartY = 0;
      let touchX = 0,
        touchY = 0;
      let phi = 0,
        theta = 0;
      let isJoystickActive = false;
      let joystickStartX = 0,
        joystickStartY = 0;
      let joystickX = 0,
        joystickY = 0;

      // Movement
      let moveForward = false,
        moveBackward = false,
        moveLeft = false,
        moveRight = false;

      // Initialize the 3D scene
      function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

        // Create camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 10, 20);
        camera.lookAt(0, 0, 0);

        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87ceeb);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document
          .getElementById("gameContainer")
          .appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(50, 50, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Create cricket field
        createField();

        // Create game objects
        createBat();
        createBall();
        createStumps();

        // Setup controls
        setupControls();

        // Start animation loop
        animate();
      }

      function createField() {
        // Create grass field
        const fieldGeometry = new THREE.PlaneGeometry(100, 100);
        const fieldMaterial = new THREE.MeshLambertMaterial({
          color: 0x00aa00,
        });
        field = new THREE.Mesh(fieldGeometry, fieldMaterial);
        field.rotation.x = -Math.PI / 2;
        field.receiveShadow = true;
        scene.add(field);

        // Create pitch
        const pitchGeometry = new THREE.PlaneGeometry(20, 4);
        const pitchMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513,
        });
        const pitch = new THREE.Mesh(pitchGeometry, pitchMaterial);
        pitch.rotation.x = -Math.PI / 2;
        pitch.position.y = 0.01;
        scene.add(pitch);

        // Create boundary
        const boundaryGeometry = new THREE.RingGeometry(45, 50, 32);
        const boundaryMaterial = new THREE.MeshLambertMaterial({
          color: 0xffffff,
        });
        const boundary = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
        boundary.rotation.x = -Math.PI / 2;
        boundary.position.y = 0.02;
        scene.add(boundary);
      }

      function createBat() {
        const batGroup = new THREE.Group();

        // Bat blade
        const bladeGeometry = new THREE.BoxGeometry(0.3, 3, 0.1);
        const bladeMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513,
        });
        const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
        blade.position.y = 1.5;
        blade.castShadow = true;
        batGroup.add(blade);

        // Bat handle
        const handleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1);
        const handleMaterial = new THREE.MeshLambertMaterial({
          color: 0x4a4a4a,
        });
        const handle = new THREE.Mesh(handleGeometry, handleMaterial);
        handle.position.y = 3.5;
        handle.castShadow = true;
        batGroup.add(handle);

        bat = batGroup;
        bat.position.set(-8, 0, 0);
        scene.add(bat);
      }

      function createBall() {
        const ballGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const ballMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
        ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.set(0, 0.2, 0);
        ball.castShadow = true;
        scene.add(ball);
      }

      function createStumps() {
        const stumpsGroup = new THREE.Group();

        // Create three stumps
        for (let i = 0; i < 3; i++) {
          const stumpGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2);
          const stumpMaterial = new THREE.MeshLambertMaterial({
            color: 0xffd700,
          });
          const stump = new THREE.Mesh(stumpGeometry, stumpMaterial);
          stump.position.set(i * 0.3 - 0.3, 1, 0);
          stump.castShadow = true;
          stumpsGroup.add(stump);
        }

        // Create bails
        for (let i = 0; i < 2; i++) {
          const bailGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3);
          const bailMaterial = new THREE.MeshLambertMaterial({
            color: 0xffd700,
          });
          const bail = new THREE.Mesh(bailGeometry, bailMaterial);
          bail.position.set(i * 0.3 - 0.15, 2.1, 0);
          bail.rotation.z = Math.PI / 2;
          bail.castShadow = true;
          stumpsGroup.add(bail);
        }

        stumps = stumpsGroup;
        stumps.position.set(8, 0, 0);
        scene.add(stumps);
      }

      function setupControls() {
        if (isMobile) {
          setupTouchControls();
        } else {
          setupDesktopControls();
        }
      }

      function setupTouchControls() {
        // Touch look controls
        renderer.domElement.addEventListener("touchstart", onTouchStart, {
          passive: false,
        });
        renderer.domElement.addEventListener("touchmove", onTouchMove, {
          passive: false,
        });
        renderer.domElement.addEventListener("touchend", onTouchEnd, {
          passive: false,
        });

        // Virtual joystick
        const joystick = document.getElementById("touch-joystick");
        joystick.addEventListener("touchstart", onJoystickStart, {
          passive: false,
        });
        joystick.addEventListener("touchmove", onJoystickMove, {
          passive: false,
        });
        joystick.addEventListener("touchend", onJoystickEnd, {
          passive: false,
        });
      }

      function setupDesktopControls() {
        // Mouse controls for desktop
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);
      }

      function onTouchStart(event) {
        event.preventDefault();
        if (event.touches.length === 1) {
          touchStartX = event.touches[0].clientX;
          touchStartY = event.touches[0].clientY;
        }
      }

      function onTouchMove(event) {
        event.preventDefault();
        if (event.touches.length === 1) {
          touchX = event.touches[0].clientX - touchStartX;
          touchY = event.touches[0].clientY - touchStartY;

          const sensitivity = 0.003;
          phi -= touchX * sensitivity;
          theta -= touchY * sensitivity;

          // Limit vertical rotation
          theta = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, theta));

          updateCameraRotation();

          touchStartX = event.touches[0].clientX;
          touchStartY = event.touches[0].clientY;
        }
      }

      function onTouchEnd(event) {
        event.preventDefault();
        touchX = 0;
        touchY = 0;
      }

      function onJoystickStart(event) {
        event.preventDefault();
        event.stopPropagation();
        isJoystickActive = true;
        const rect = event.target.getBoundingClientRect();
        joystickStartX = rect.left + rect.width / 2;
        joystickStartY = rect.top + rect.height / 2;
      }

      function onJoystickMove(event) {
        if (!isJoystickActive) return;
        event.preventDefault();
        event.stopPropagation();

        const touch = event.touches[0];
        const deltaX = touch.clientX - joystickStartX;
        const deltaY = touch.clientY - joystickStartY;

        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const maxDistance = 25;

        if (distance < maxDistance) {
          joystickX = deltaX / maxDistance;
          joystickY = deltaY / maxDistance;
        } else {
          joystickX = (deltaX / distance) * (maxDistance / maxDistance);
          joystickY = (deltaY / distance) * (maxDistance / maxDistance);
        }

        // Update joystick knob position
        const knob = document.getElementById("touch-joystick-knob");
        knob.style.transform = `translate(${joystickX * 25 - 50}%, ${
          joystickY * 25 - 50
        }%)`;

        // Set movement flags
        moveForward = joystickY < -0.3;
        moveBackward = joystickY > 0.3;
        moveLeft = joystickX < -0.3;
        moveRight = joystickX > 0.3;
      }

      function onJoystickEnd(event) {
        event.preventDefault();
        event.stopPropagation();
        isJoystickActive = false;
        joystickX = 0;
        joystickY = 0;

        // Reset knob position
        const knob = document.getElementById("touch-joystick-knob");
        knob.style.transform = "translate(-50%, -50%)";

        // Reset movement flags
        moveForward = moveBackward = moveLeft = moveRight = false;
      }

      function onMouseMove(event) {
        // Desktop mouse controls (existing code can be added here if needed)
      }

      function onKeyDown(event) {
        switch (event.code) {
          case "KeyW":
            moveForward = true;
            break;
          case "KeyA":
            moveLeft = true;
            break;
          case "KeyS":
            moveBackward = true;
            break;
          case "KeyD":
            moveRight = true;
            break;
        }
      }

      function onKeyUp(event) {
        switch (event.code) {
          case "KeyW":
            moveForward = false;
            break;
          case "KeyA":
            moveLeft = false;
            break;
          case "KeyS":
            moveBackward = false;
            break;
          case "KeyD":
            moveRight = false;
            break;
        }
      }

      function updateCameraRotation() {
        const x = Math.sin(phi) * Math.cos(theta);
        const y = Math.sin(theta);
        const z = Math.cos(phi) * Math.cos(theta);

        const target = new THREE.Vector3(
          camera.position.x + x,
          camera.position.y + y,
          camera.position.z + z
        );

        camera.lookAt(target);
      }

      function updateCameraMovement() {
        const moveSpeed = 0.5;
        const direction = new THREE.Vector3();
        const right = new THREE.Vector3();

        // Calculate forward direction
        const forward = new THREE.Vector3(
          Math.sin(phi),
          0,
          Math.cos(phi)
        ).normalize();

        // Calculate right direction
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

        if (moveForward) {
          direction.add(forward);
        }
        if (moveBackward) {
          direction.sub(forward);
        }
        if (moveLeft) {
          direction.sub(right);
        }
        if (moveRight) {
          direction.add(right);
        }

        if (direction.length() > 0) {
          direction.normalize().multiplyScalar(moveSpeed);
          camera.position.add(direction);
        }
      }

      function animate() {
        requestAnimationFrame(animate);

        // Update camera movement
        updateCameraMovement();

        // Rotate objects slowly
        if (!isAnimating) {
          bat.rotation.y += 0.01;
          ball.rotation.x += 0.02;
          ball.rotation.z += 0.01;
          stumps.rotation.y += 0.01;
        }

        renderer.render(scene, camera);
      }

      function playGame(playerChoice) {
        if (isAnimating) return;

        isAnimating = true;
        matches++;
        document.getElementById("matches").textContent = matches;

        // Generate computer choice
        const choices = ["Bat", "Ball", "Stump"];
        const computerChoice = choices[Math.floor(Math.random() * 3)];

        // Determine result
        let result;
        if (playerChoice === computerChoice) {
          result = "Tie!";
        } else if (
          (playerChoice === "Bat" && computerChoice === "Ball") ||
          (playerChoice === "Ball" && computerChoice === "Stump") ||
          (playerChoice === "Stump" && computerChoice === "Bat")
        ) {
          result = "You Win!";
          score++;
          document.getElementById("score").textContent = score;
        } else {
          result = "Computer Wins!";
        }

        // Animate the chosen objects
        animateChoice(playerChoice, computerChoice);

        // Show result after animation
        setTimeout(() => {
          showResult(playerChoice, computerChoice, result);
          isAnimating = false;
        }, 2500);
      }

      function animateChoice(playerChoice, computerChoice) {
        // Determine the type of interaction and animate accordingly
        if (playerChoice === "Ball" && computerChoice === "Stump") {
          // Ball hits stump - player wins
          animateBallHitStump();
        } else if (playerChoice === "Stump" && computerChoice === "Ball") {
          // Ball hits stump - computer wins
          animateBallHitStump();
        } else if (playerChoice === "Bat" && computerChoice === "Ball") {
          // Bat hits ball - player wins
          animateBatHitBall();
        } else if (playerChoice === "Ball" && computerChoice === "Bat") {
          // Bat hits ball - computer wins
          animateBatHitBall();
        } else if (playerChoice === "Stump" && computerChoice === "Bat") {
          // Bat breaks stump - player wins
          animateBatBreakStump();
        } else if (playerChoice === "Bat" && computerChoice === "Stump") {
          // Bat breaks stump - computer wins
          animateBatBreakStump();
        } else {
          // Same choice - tie animation
          animateTie(playerChoice);
        }
      }

      function animateBallHitStump() {
        // Reset positions
        resetObjectPositions();

        // Animate ball moving towards stumps
        const ballStartPos = { x: -10, y: 0.2, z: 0 };
        const stumpPos = { x: 8, y: 0, z: 0 };

        ball.position.set(ballStartPos.x, ballStartPos.y, ballStartPos.z);

        const duration = 1500;
        const startTime = Date.now();

        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);

          if (progress < 0.7) {
            // Ball moving towards stump
            const moveProgress = progress / 0.7;
            ball.position.x =
              ballStartPos.x + (stumpPos.x - ballStartPos.x) * moveProgress;
            ball.position.y =
              ballStartPos.y + Math.sin(moveProgress * Math.PI) * 2;
            ball.rotation.x += 0.3;
            ball.rotation.z += 0.2;
          } else {
            // Impact animation
            const impactProgress = (progress - 0.7) / 0.3;
            ball.position.x = stumpPos.x;
            ball.position.y = ballStartPos.y;

            // Stumps fall back
            stumps.rotation.z = (impactProgress * Math.PI) / 4;
            stumps.position.y = -impactProgress * 0.5;

            // Ball bounces back
            ball.position.x = stumpPos.x + impactProgress * 2;
            ball.position.y =
              ballStartPos.y + Math.sin(impactProgress * Math.PI) * 1;
          }

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            // Reset after animation
            setTimeout(() => {
              resetObjectPositions();
            }, 500);
          }
        }

        animate();
      }

      function animateBatHitBall() {
        // Reset positions
        resetObjectPositions();

        const batStartPos = { x: -8, y: 0, z: 0 };
        const ballStartPos = { x: 0, y: 0.2, z: 0 };

        const duration = 1500;
        const startTime = Date.now();

        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);

          if (progress < 0.5) {
            // Bat swinging towards ball
            const swingProgress = progress / 0.5;
            bat.rotation.z = (-swingProgress * Math.PI) / 2;
            bat.position.x = batStartPos.x + swingProgress * 6;
            bat.position.y = swingProgress * 2;
          } else if (progress < 0.7) {
            // Impact moment
            const impactProgress = (progress - 0.5) / 0.2;
            bat.rotation.z = -Math.PI / 2;
            bat.position.x = batStartPos.x + 6;
            bat.position.y = 2;

            // Ball starts flying
            ball.position.x = ballStartPos.x + impactProgress * 15;
            ball.position.y = ballStartPos.y + impactProgress * 8;
            ball.rotation.x += 0.5;
            ball.rotation.y += 0.3;
          } else {
            // Follow through
            const followProgress = (progress - 0.7) / 0.3;
            bat.rotation.z = -Math.PI / 2 + (followProgress * Math.PI) / 3;

            // Ball continues flying
            ball.position.x = ballStartPos.x + 15 + followProgress * 10;
            ball.position.y = ballStartPos.y + 8 - followProgress * 6;
            ball.rotation.x += 0.3;
            ball.rotation.y += 0.2;
          }

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            // Reset after animation
            setTimeout(() => {
              resetObjectPositions();
            }, 500);
          }
        }

        animate();
      }

      function animateBatBreakStump() {
        // Reset positions
        resetObjectPositions();

        const batStartPos = { x: -8, y: 0, z: 0 };
        const stumpPos = { x: 8, y: 0, z: 0 };

        const duration = 1500;
        const startTime = Date.now();

        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);

          if (progress < 0.6) {
            // Bat moving towards stump
            const moveProgress = progress / 0.6;
            bat.position.x =
              batStartPos.x + (stumpPos.x - batStartPos.x) * moveProgress;
            bat.position.y = Math.sin(moveProgress * Math.PI) * 3;
            bat.rotation.z = (moveProgress * Math.PI) / 2;
          } else {
            // Impact and destruction
            const impactProgress = (progress - 0.6) / 0.4;
            bat.position.x = stumpPos.x;
            bat.position.y = 0;
            bat.rotation.z = Math.PI / 2;

            // Stumps scatter
            stumps.rotation.x = (impactProgress * Math.PI) / 2;
            stumps.rotation.y = (impactProgress * Math.PI) / 3;
            stumps.position.y = -impactProgress * 2;
            stumps.position.x = stumpPos.x + impactProgress * 3;
          }

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            // Reset after animation
            setTimeout(() => {
              resetObjectPositions();
            }, 500);
          }
        }

        animate();
      }

      function animateTie(choice) {
        // Both objects do a synchronized dance
        const object = getObjectByChoice(choice);
        const duration = 1500;
        const startTime = Date.now();

        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);

          // Synchronized spinning and bouncing
          const bounce = Math.sin(progress * Math.PI * 4) * 2;
          object.position.y = object.position.y + bounce * 0.1;
          object.rotation.y += 0.15;

          if (choice === "Ball") {
            object.rotation.x += 0.1;
            object.rotation.z += 0.1;
          }

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            resetObjectPositions();
          }
        }

        animate();
      }

      function getObjectByChoice(choice) {
        switch (choice) {
          case "Bat":
            return bat;
          case "Ball":
            return ball;
          case "Stump":
            return stumps;
          default:
            return bat;
        }
      }

      function resetObjectPositions() {
        // Reset bat
        bat.position.set(-8, 0, 0);
        bat.rotation.set(0, 0, 0);

        // Reset ball
        ball.position.set(0, 0.2, 0);
        ball.rotation.set(0, 0, 0);

        // Reset stumps
        stumps.position.set(8, 0, 0);
        stumps.rotation.set(0, 0, 0);
      }

      function showResult(playerChoice, computerChoice, result) {
        const resultDiv = document.getElementById("result");
        const resultText = document.getElementById("result-text");

        resultText.innerHTML = `
          <h3>${result}</h3>
          <p>You chose: ${playerChoice}</p>
          <p>Computer chose: ${computerChoice}</p>
          <p>Score: ${score} | Matches: ${matches}</p>
        `;

        resultDiv.style.display = "block";
      }

      function closeResult() {
        document.getElementById("result").style.display = "none";
      }

      // Handle window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Initialize the game
      init();
    </script>
  </body>
</html>
